var gulp           = require('gulp'),
    path           = require('path');

var $ = require('gulp-load-plugins')({
  pattern: ['gulp-*', 'main-bower-files', 'run-sequence'],
  rename: {
    'gulp-angular-templatecache': 'templateCache'
  }
});

$.wiredep = require('wiredep').stream;

var config = {
  app: 'app',
  dist: 'dist',
  tmp: '.tmp'
};

// === Pipes ===
var pipes = {};
/*
 * Pipe for injecting custom CSS and JavaScript into the index.html,
 * notice that we are ignoring the path '../.tmp/app' because of the
 * 'styles.css' file generated by the 'less' task, i.e., the 'styles.css'
 * file will be in the '.tmp/app/assets/css' folder but we don't want
 * that long path in the index.html script, we are only including 'assets/css'.
 */
pipes.injectCustom = function() {
  var sources = gulp.src([
    path.join('!' + config.app, '/lib/**/*'),
    path.join(config.app, '/**/*.js'),
    path.join(config.tmp, config.app, '/assets/css/**/*.css')
  ], { read: false });
  return $.inject(sources, { relative: true, ignorePath: '../.tmp/app' });
};

/*
 * Pipe for injecting custom CSS and JavaScript into the index.html
 */
pipes.injectVendor = function() {
  return $.wiredep();
};

// === Tasks ===
/*
 * Generates a single .css from .less files located in /assets/less/
 */
gulp.task('less', function () {
  return gulp.src(path.join(config.app, '/assets/less/styles.less'))
    .pipe($.less())
    .pipe(gulp.dest(path.join(config.tmp, config.app, '/assets/css')));
});

/*
 * Injects both vendor and customs scripts and styles into the index.html file.
 * Leaves the output file in the '.tmp' folder.
 */
gulp.task('inject', ['less'], function () {
  return gulp.src(path.join(config.app, '/index.html'))
    .pipe(pipes.injectCustom())
    .pipe(pipes.injectVendor())
    .pipe(gulp.dest(path.join(config.tmp, config.app)));
});

/*
 * Generates AngularJS templateCache for each .html file specified.
 * The output file contains a task that would run in the main module.
 */
gulp.task('partials', function() {
  return gulp.src([
    path.join(config.app, '**/*.html'),
    path.join('!' + config.app, '/index.html'),
    path.join('!' + config.app, '/lib/**/*.html')
  ])
    .pipe($.htmlmin({ collapseWhitespace: true }))
    .pipe($.templateCache({
      module: 'tf-client'
    }))
    .pipe(gulp.dest(path.join(config.tmp, '/partials')))
});

/*
 * Injects the generated file by 'partials' task into the index.html
 */
gulp.task('inject:partials', ['inject', 'partials'], function() {
  var partials = gulp.src(path.join(config.tmp, '/partials/templates.js'), { read: false });
  var options = {
    starttag: '<!-- inject:partials -->',
    ignorePath: path.join(config.tmp, '/partials'),
    addRootSlash: false
  };
  return gulp.src(path.join(config.tmp, config.app, '/index.html'))
    .pipe($.inject(partials, options))
    .pipe(gulp.dest(path.join(config.tmp, config.app)));
});

/*
 * This guy does magic, it takes the the content that is inside the blocks
 * like '<-- build:js -->' and generates a single file including all.
 * So, here we are concatenating, annotating, minifying and versioning all
 * the scripts, styles and index files.
 */
gulp.task('useref', ['inject:partials'], function() {
  return gulp.src(path.join(config.tmp, config.app, '/index.html'))
      .pipe($.useref())
      .pipe($.if('*.js', $.ngAnnotate()))
      .pipe($.if('*.js', $.uglify()))
      .pipe($.if('*.css', $.minifyCss({ processImport: false })))
      .pipe($.if('!*.html', $.rev()))
      .pipe($.revReplace())
      .pipe($.if('*.html', $.htmlmin({
        removeAttributeQuotes: true,
        collapseWhitespace: true
      })))
      .pipe(gulp.dest(config.dist));
});

/*
 * Copies the fonts from bower dependencies into the dist folder.
 * Custom fonts are handled by the 'copy' task
 * NOTE: An override for font-awesome was added in our bower.json file.
 */
gulp.task('fonts', function () {
  return gulp.src($.mainBowerFiles())
    .pipe($.filter('**/*.{eot,svg,ttf,woff,woff2}'))
    .pipe(gulp.dest(path.join(config.dist, '/fonts')));
});

/*
 * Copies the fonts, images and other files from the source to the dist folder.
 */
gulp.task('copy', function () {
  var fileFilter = $.filter(function (file) {
    return file.stat.isFile();
  });
  return gulp.src([
    path.join(config.app, '/**/*'),
    path.join('!' + config.app, '/**/*.{html,css,js,less}'),
    path.join('!' + config.app, '/lib/**/*')
  ])
    .pipe(fileFilter)
    .pipe(gulp.dest(config.dist));
});

/*
 * Runs all required tasks to build a dist version of the project.
 */
gulp.task('build', function (callback) {
  $.runSequence('clean', ['useref', 'fonts', 'copy'], function() {
    callback();
  });
});

/*
 * Runs all required tasks to build a development version of the project.
 */
gulp.task('build:dev', function (callback) {
  $.runSequence('clean', ['inject:partials'], function() {
    callback();
  });
});

/*
 * Runs the development version of the project.
 */
gulp.task('serve', function (callback) {
  $.runSequence('build:dev', 'open', function () {
    $.express.run('app.js');
    callback();
  });
});

/*
 * Runs the distribution version of the project.
 */
gulp.task('serve:dist', function(callback) {
  $.runSequence('build', 'open', function() {
    $.express.run('app.js');
    callback();
  });
});

/*
 * Opens a browser tab with the localhost running server.
 */
gulp.task('open', function () {
  var port = process.env.TASKFLEX_FRONT_END_PORT || 8000;
  var options = {
    uri: 'http://localhost:' + port,
  };
  gulp.src(__filename)
    .pipe($.open(options));
});

/*
 * Cleans the temporal and distribution folders.
 */
gulp.task('clean', function() {
  return gulp.src([
    config.dist,
    config.tmp
  ], { read: false })
    .pipe($.clean());
});

gulp.task('default', ['serve']);
